"""Utilities for comparing MEGqc metrics across multiple samples.

This script expects the TSV files generated by the MEGqc pipeline for each
sample and produces a set of violin plots, a linear regression table and
scatter plots comparing the samples.

Example
-------
Assuming you have the metrics exported for two datasets, run::

    python -m meg_qc.calculation.between_sample_analysis \
        --tsv sample1/group_metrics.tsv sample2/group_metrics.tsv \
        --names sample1 sample2 \
        --output-dir results

All figures and the regression table will be stored in ``results``.
"""
import argparse
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import statsmodels.api as sm

LABEL_MAP = {
    "GQI": "GQI",
    "GQI_std_pct": "STD noise",
    "GQI_ptp_pct": "PtP noise",
    "GQI_ecg_pct": "ECG noise",
    "GQI_eog_pct": "EOG noise",
    "GQI_muscle_pct": "Muscle noise",
    "GQI_psd_noise_pct": "PSD noise",
    "GQI_penalty_ch": "Variability penalty",
    "GQI_penalty_corr": "Correlational penalty",
    "GQI_penalty_mus": "Muscle penalty",
    "GQI_penalty_psd": "PSD penalty",
}


def _load_tables(paths):
    """Load TSV tables into pandas DataFrames."""
    tables = []
    for p in paths:
        df = pd.read_csv(p, sep="\t")
        tables.append(df)
    return tables


def _make_violin(data, names, title, ylabel, out_png):
    """Create violin plot comparing samples."""
    violin_data = [d.dropna() for d in data]
    palette = cm.get_cmap("tab10", len(violin_data))
    plt.figure(figsize=(10, 6))
    parts = plt.violinplot(violin_data, showmeans=True, showextrema=True,
                            showmedians=False, widths=0.8)
    for i, pc in enumerate(parts["bodies"]):
        pc.set_facecolor(palette(i))
        pc.set_edgecolor("black")
        pc.set_alpha(0.5)
    parts["cmeans"].set_linewidth(2)
    parts["cmeans"].set_color("black")
    parts["cbars"].set_color("black")
    for i, y in enumerate(violin_data, start=1):
        x = np.random.normal(i, 0.05, size=len(y))
        plt.scatter(x, y, s=20, alpha=0.4, edgecolor="black", linewidth=0.5,
                    facecolor=palette(i - 1))
    plt.xticks(range(1, len(names) + 1), names, rotation=0, ha="center", fontsize=10)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.tight_layout()
    plt.savefig(out_png, dpi=300)
    plt.close()


def _cumulative_plot(tables, metrics, names, out_png):
    """Create a cumulative violin plot of several metrics for each sample."""
    n_samples = len(names)
    fig, ax = plt.subplots(figsize=(12, 6))
    palette = cm.get_cmap("tab10", len(metrics))

    positions = []
    labels = []
    for j, metric in enumerate(metrics):
        for i, name in enumerate(names):
            data = tables[i][metric].dropna()
            pos = j * n_samples + i + 1
            parts = ax.violinplot(
                [data],
                positions=[pos],
                showmeans=True,
                showextrema=True,
                showmedians=False,
                widths=0.8,
            )
            color = palette(j)
            for pc in parts["bodies"]:
                pc.set_facecolor(color)
                pc.set_edgecolor("black")
                pc.set_alpha(0.5)
            parts["cmeans"].set_linewidth(2)
            parts["cmeans"].set_color("black")
            parts["cbars"].set_color("black")
            x = np.random.normal(pos, 0.05, size=len(data))
            ax.scatter(
                x,
                data,
                s=20,
                alpha=0.4,
                edgecolor="black",
                linewidth=0.5,
                facecolor=color,
            )
            positions.append(pos)
            labels.append(name)

    ax.set_xticks(positions)
    ax.set_xticklabels(labels, rotation=0, ha="center", fontsize=9)
    ax.set_ylabel("Percentage of Quality and Noisy Channels")
    ax.set_title("Metrics across samples")

    secax = ax.secondary_xaxis(
        "bottom",
        functions=(lambda x: x, lambda x: x),
    )
    centers = [j * n_samples + (n_samples + 1) / 2 for j in range(len(metrics))]
    secax.set_xticks(centers)
    secax.set_xticklabels([LABEL_MAP.get(m, m) for m in metrics], fontsize=10, fontweight="bold")
    secax.tick_params(pad=20)

    fig.tight_layout()
    fig.savefig(out_png, dpi=300)
    plt.close(fig)


def _perform_regression(df, metrics, out_tsv):
    """Run linear regression and save results."""
    X = df[metrics].copy()
    # add all pairwise interactions
    for i, m1 in enumerate(metrics):
        for m2 in metrics[i + 1:]:
            X[f"{m1}:{m2}"] = df[m1] * df[m2]
    X = sm.add_constant(X)
    model = sm.OLS(df["GQI"], X, missing="drop").fit()
    res_df = pd.DataFrame({
        "variable": model.params.index,
        "coef": model.params.values,
        "std_err": model.bse.values,
        "t": model.tvalues.values,
        "p": model.pvalues.values,
    })
    res_df.to_csv(out_tsv, sep="\t", index=False)
    return model


def _scatter_plots(df, model, metrics, out_dir):
    """Create scatter plots for each metric with regression line."""
    for m in metrics:
        if m not in df.columns:
            continue
        plt.figure(figsize=(8, 6))
        plt.scatter(df[m], df["GQI"], alpha=0.6, edgecolor="black")

        x = np.linspace(df[m].min(), df[m].max(), 100)
        pred_data = {}
        for var in model.params.index:
            if var == "const":
                continue
            if var == m:
                pred_data[var] = x
            elif ":" in var:
                m1, m2 = var.split(":")
                if m1 == m:
                    val1 = x
                    val2 = df[m2].mean()
                elif m2 == m:
                    val1 = df[m1].mean()
                    val2 = x
                else:
                    val1 = df[m1].mean()
                    val2 = df[m2].mean()
                pred_data[var] = val1 * val2
            else:
                pred_data[var] = df[var].mean()
        X_new = pd.DataFrame(pred_data)
        X_new = sm.add_constant(X_new, has_constant="add")
        preds = model.get_prediction(X_new).summary_frame(alpha=0.05)
        plt.plot(x, preds["mean"], color="red")
        plt.fill_between(
            x,
            preds["mean_ci_lower"],
            preds["mean_ci_upper"],
            color="red",
            alpha=0.2,
        )
        beta = model.params.get(m, float("nan"))
        pval = model.pvalues.get(m, float("nan"))
        plt.annotate(
            f"Î²={beta:.3f}, p={pval:.3g}",
            xy=(0.05, 0.95),
            xycoords="axes fraction",
            ha="left",
            va="top",
        )
        plt.xlabel(LABEL_MAP.get(m, m))
        plt.ylabel("GQI")
        plt.title(f"GQI vs {LABEL_MAP.get(m, m)}")
        plt.tight_layout()
        plt.savefig(os.path.join(out_dir, f"{m}_scatter.png"), dpi=300)
        plt.close()


def main():
    parser = argparse.ArgumentParser(description="Between sample analysis")
    parser.add_argument("--tsv", nargs="+", required=True,
                        help="Paths to group metrics TSV files")
    parser.add_argument("--names", nargs="+", required=True,
                        help="Sample names corresponding to TSV files")
    parser.add_argument("--output-dir", required=True, help="Directory for outputs")
    args = parser.parse_args()

    if len(args.tsv) != len(args.names):
        raise ValueError("Number of TSV files must match number of names")

    os.makedirs(args.output_dir, exist_ok=True)
    cumulative_dir = os.path.join(args.output_dir, "cummlative_violin_plot")
    separated_dir = os.path.join(args.output_dir, "separated_violin_plot")
    regression_dir = os.path.join(args.output_dir, "regression")
    os.makedirs(cumulative_dir, exist_ok=True)
    os.makedirs(separated_dir, exist_ok=True)
    os.makedirs(regression_dir, exist_ok=True)

    tables = _load_tables(args.tsv)
    metrics = [
        "GQI_std_pct",
        "GQI_ptp_pct",
        "GQI_ecg_pct",
        "GQI_eog_pct",
        "GQI_muscle_pct",
        "GQI_psd_noise_pct",
    ]

    # Violin plot for GQI
    gqi_data = [tbl["GQI"] for tbl in tables]
    _make_violin(
        gqi_data,
        args.names,
        "Global Quality Index",
        LABEL_MAP["GQI"],
        os.path.join(separated_dir, "GQI_violin.png"),
    )

    # Metric specific violin plots
    for m in metrics:
        metric_data = [t[m] for t in tables if m in t.columns]
        if not metric_data:
            continue
        _make_violin(
            metric_data,
            args.names,
            LABEL_MAP.get(m, m),
            LABEL_MAP.get(m, m),
            os.path.join(separated_dir, f"{m}_violin.png"),
        )

    _cumulative_plot(
        tables,
        ["GQI", *metrics],
        args.names,
        os.path.join(cumulative_dir, "cumulative_metrics.png"),
    )

    # Combine all data for regression
    df_all = []
    for name, tbl in zip(args.names, tables):
        temp = tbl.copy()
        temp["sample"] = name
        df_all.append(temp)
    df_all = pd.concat(df_all, ignore_index=True)

    reg_model = _perform_regression(
        df_all, metrics, os.path.join(regression_dir, "linear_regression_results.tsv")
    )

    _scatter_plots(df_all, reg_model, metrics, regression_dir)


if __name__ == "__main__":
    main()
